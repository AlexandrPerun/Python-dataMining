import random as rnd
import matplotlib.pyplot as plt

truancy =[]                             # создаем список для хранения данных о количестве прогулов
point = []                              # создаем список для хранения данных об оценках
for i in range(100):                    # цикл для генерации данных
    x = rnd.randint(0,100)              # генерируем число прогулов
    truancy.append(x)                   # вносим число прогулов в список
    if x >= 0 and x < 25:               # если число прогулов находится в пределе от 0 до 25
        point.append(rnd.randint(4,5))  # генерируем оценку в пределах от 4 до 5
    if x >= 25 and x < 50:              # если число прогулов находится в пределе от 25 до 50
        point.append(rnd.randint(3,4))  # генерируем оценку в пределах от 3 до 4
    if x >= 50 and x < 75:              # если число прогулов находится в пределе от 50 до 75
        point.append(rnd.randint(2,3))  # генерируем оценку в пределах от 2 до 3
    if x >= 75 and x <= 100:            # если число прогулов находится в пределе от 75 до 100
        point.append(rnd.randint(0,2))  # генерируем оценку в пределах от 0 до 2
        
Ax = 10             # задаем начальное х-координату эталонной точки для первого кластера
Ay = 5              # задаем начальное у-координату эталонной точки для первого кластера
Bx = 30             # задаем начальное х-координату эталонной точки для второго кластера
By = 4              # задаем начальное у-координату эталонной точки для второго кластера
Cx = 80             # задаем начальное х-координату эталонной точки для третьего кластера
Cy = 2              # задаем начальное у-координату эталонной точки для третьего кластера
Dx = 100            # задаем начальное х-координату эталонной точки для четвертого кластера
Dy = 0              # задаем начальное у-координату эталонной точки для четвертого кластера


while True:         #  цикл для поиска минимальных расстояний и пересчет значений для эталонных точек
    dist = 1000     # задаем эталонное значение для расстояния
    for i in range(100):    # находим минимальное расстояние от каждой точки из первого кластера до эталонной точки
        d = ((truancy[i] - Ax)**2 + (point[i] - Ay)**2)**0.5    # считаем Эвклидово рассстояние
        if d < dist:        # сравниваем полученное расстояние с эталонным значением
                            # если полученное расстояние меньше, чем эталонное
            dist = d        # переопределяем эталонное расстояние, присвоив ему полученное значение
            x1 = truancy[i] # запоминаем координаты точки, расстояние от которой до эталонной точки на данный момент минимально
            y1 = point[i]

    # далее повторяем те же действия для оставшихся трёх кластеров
    dist = 1000
    for i in range(100):
        d = ((truancy[i] - Bx)**2 + (point[i] - By)**2)**0.5
        if d < dist:
            dist = d
            x2 = truancy[i]
            y2 = point[i]
    
    dist = 1000 
    for i in range(100):
        d = ((truancy[i] - Cx)**2 + (point[i] - Cy)**2)**0.5
        if d < dist:
            dist = d
            x3 = truancy[i]
            y3 = point[i]
    
    dist = 1000
    for i in range(100):
        d = ((truancy[i] - Dx)**2 + (point[i] - Dy)**2)**0.5
        if d < dist:
            dist = d
            x4 = truancy[i]
            y4 = point[i]
    
    # производим проверку: если, прибавив к эталонной точке значение временного центра и разделив на два, мы получаем то же самое значение эталонной точки,
    # то границы кластеров не изменились, т.е. в каждом кластере будет оставаться один и тот же набор записей
    if (Ax + x1)/2 == Ax and (Ay + y1)/2 == Ay and (Bx + x2)/2 == Bx and (By + y2)/2 == By and (Cx + x3)/2 == Cx and (Cy + y3)/2 == Cy and (Dx + x4)/2 == Dx and (Dy + y4)/2 == Dy:
        truancy.append(x1)      # вносим в список хранения данных о прогулах х-координату центра первого кластера
        color.append('black')   # вносим в список цветов цвет для определения центра первого кластера
        truancy.append(x2)      # вносим в список хранения данных о прогулах х-координату центра второго кластера
        color.append('black')   # вносим в список цветов цвет для определения центра второго кластера
        truancy.append(x3)      # вносим в список хранения данных о прогулах х-координату центра третьего кластера
        color.append('black')   # вносим в список цветов цвет для определения центра третьего кластера
        truancy.append(x4)      # вносим в список хранения данных о прогулах х-координату центра четвертого кластера
        color.append('black')   # вносим в список цветов цвет для определения центра четвертого кластера
        point.append(y1)        # вносим в список хранения данных об оценках у-координату центра первого кластера
        point.append(y2)        # вносим в список хранения данных об оценках у-координату центра второго кластера
        point.append(y3)        # вносим в список хранения данных об оценках у-координату центра тертьего кластера
        point.append(y4)        # вносим в список хранения данных об оценках у-координату центра четвертого кластера
        break                   # останавливаем процесс кластеризации

    else:           # иначе переопределяем значения для эталонных точек
        Ax = (Ax + x1)/2
        Ay = (Ay + y1)/2
        Bx = (Bx + x2)/2
        By = (By + y2)/2
        Cx = (Cx + x3)/2
        Cy = (Cy + y3)/2
        Dx = (Dx + x4)/2
        Dy = (Dy + y4)/2

    # разбиваем объекты на кластеры
    A, B, C, D, color = [],[], [], [], []   # создаем списки для хранения кластеров и список для хранения цветов
    for i in range(100):                    # для каждой точки из массивов
        d1 = ((truancy[i] - Ax)**2 + (point[i] - Ay)**2)**0.5   # рассчитываем эвклидово расстояниее до каждого центра кластера
        d2 = ((truancy[i] - Bx)**2 + (point[i] - By)**2)**0.5
        d3 = ((truancy[i] - Cx)**2 + (point[i] - Cy)**2)**0.5
        d4 = ((truancy[i] - Dx)**2 + (point[i] - Dy)**2)**0.5
        Min = min(d1, d2, d3, d4)           # находим минимальное расстояние
        # определяем к какому именно кластеру нужно отнести точку
        if Min == d1:               # если минимальное расстояние равное d1
            A.append([truancy[i], point[i]])    # добавляем точку в первый кластер
            color.append('red')     # добавляем красный цвет в массив цветов
        elif Min == d2:             # если минимальное расстояние равное d2
            B.append([truancy[i], point[i]])    # добавляем точку во второй кластер
            color.append('blue')    # добавляем синий цвет в массив цветов
        elif Min == d3:             # если минимальное расстояние равное d3
            C.append([truancy[i], point[i]])    # добавляем точку в третий кластер
            color.append('green')   # добавляем зеленый цвет в массив цветов
        elif Min == d4:             # если минимальное расстояние равное d4
            D.append([truancy[i], point[i]])    # добавляем точку в четвертый кластер
            color.append('yellow')  # добавляем желтый цвет в массив цветов

print('A = ', A,'\n', 'B = ', B,'\n', 'C = ', C,'\n', 'D = ', D)    # выводим сформированный кластеры на экран
plt.scatter(truancy, point, c = color)      # создаем графическое отображение кластеров
plt.show()    

